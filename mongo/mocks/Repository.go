// Code generated by mockery v2.36.0. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	mongo "go.mongodb.org/mongo-driver/mongo"

	repository "github.com/bldsoft/gost/repository"
)

// Repository is an autogenerated mock type for the Repository type
type Repository[T interface{}, U repository.IEntityIDPtr[T]] struct {
	mock.Mock
}

type Repository_Expecter[T interface{}, U repository.IEntityIDPtr[T]] struct {
	mock *mock.Mock
}

func (_m *Repository[T, U]) EXPECT() *Repository_Expecter[T, U] {
	return &Repository_Expecter[T, U]{mock: &_m.Mock}
}

// AggregateOne provides a mock function with given fields: ctx, pipeline, entity
func (_m *Repository[T, U]) AggregateOne(ctx context.Context, pipeline mongo.Pipeline, entity interface{}) error {
	ret := _m.Called(ctx, pipeline, entity)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, mongo.Pipeline, interface{}) error); ok {
		r0 = rf(ctx, pipeline, entity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_AggregateOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AggregateOne'
type Repository_AggregateOne_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// AggregateOne is a helper method to define mock.On call
//   - ctx context.Context
//   - pipeline mongo.Pipeline
//   - entity interface{}
func (_e *Repository_Expecter[T, U]) AggregateOne(ctx interface{}, pipeline interface{}, entity interface{}) *Repository_AggregateOne_Call[T, U] {
	return &Repository_AggregateOne_Call[T, U]{Call: _e.mock.On("AggregateOne", ctx, pipeline, entity)}
}

func (_c *Repository_AggregateOne_Call[T, U]) Run(run func(ctx context.Context, pipeline mongo.Pipeline, entity interface{})) *Repository_AggregateOne_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(mongo.Pipeline), args[2].(interface{}))
	})
	return _c
}

func (_c *Repository_AggregateOne_Call[T, U]) Return(_a0 error) *Repository_AggregateOne_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_AggregateOne_Call[T, U]) RunAndReturn(run func(context.Context, mongo.Pipeline, interface{}) error) *Repository_AggregateOne_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// Collection provides a mock function with given fields:
func (_m *Repository[T, U]) Collection() *mongo.Collection {
	ret := _m.Called()

	var r0 *mongo.Collection
	if rf, ok := ret.Get(0).(func() *mongo.Collection); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.Collection)
		}
	}

	return r0
}

// Repository_Collection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Collection'
type Repository_Collection_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// Collection is a helper method to define mock.On call
func (_e *Repository_Expecter[T, U]) Collection() *Repository_Collection_Call[T, U] {
	return &Repository_Collection_Call[T, U]{Call: _e.mock.On("Collection")}
}

func (_c *Repository_Collection_Call[T, U]) Run(run func()) *Repository_Collection_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Repository_Collection_Call[T, U]) Return(_a0 *mongo.Collection) *Repository_Collection_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Collection_Call[T, U]) RunAndReturn(run func() *mongo.Collection) *Repository_Collection_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, id, options
func (_m *Repository[T, U]) Delete(ctx context.Context, id interface{}, options ...*repository.QueryOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) error); ok {
		r0 = rf(ctx, id, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Repository_Delete_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id interface{}
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) Delete(ctx interface{}, id interface{}, options ...interface{}) *Repository_Delete_Call[T, U] {
	return &Repository_Delete_Call[T, U]{Call: _e.mock.On("Delete",
		append([]interface{}{ctx, id}, options...)...)}
}

func (_c *Repository_Delete_Call[T, U]) Run(run func(ctx context.Context, id interface{}, options ...*repository.QueryOptions)) *Repository_Delete_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Delete_Call[T, U]) Return(_a0 error) *Repository_Delete_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Delete_Call[T, U]) RunAndReturn(run func(context.Context, interface{}, ...*repository.QueryOptions) error) *Repository_Delete_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// DeleteMany provides a mock function with given fields: ctx, filter, options
func (_m *Repository[T, U]) DeleteMany(ctx context.Context, filter interface{}, options ...*repository.QueryOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, filter)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) error); ok {
		r0 = rf(ctx, filter, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_DeleteMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMany'
type Repository_DeleteMany_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// DeleteMany is a helper method to define mock.On call
//   - ctx context.Context
//   - filter interface{}
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) DeleteMany(ctx interface{}, filter interface{}, options ...interface{}) *Repository_DeleteMany_Call[T, U] {
	return &Repository_DeleteMany_Call[T, U]{Call: _e.mock.On("DeleteMany",
		append([]interface{}{ctx, filter}, options...)...)}
}

func (_c *Repository_DeleteMany_Call[T, U]) Run(run func(ctx context.Context, filter interface{}, options ...*repository.QueryOptions)) *Repository_DeleteMany_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Repository_DeleteMany_Call[T, U]) Return(_a0 error) *Repository_DeleteMany_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_DeleteMany_Call[T, U]) RunAndReturn(run func(context.Context, interface{}, ...*repository.QueryOptions) error) *Repository_DeleteMany_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: ctx, filter, opt
func (_m *Repository[T, U]) Find(ctx context.Context, filter interface{}, opt ...*repository.QueryOptions) ([]U, error) {
	_va := make([]interface{}, len(opt))
	for _i := range opt {
		_va[_i] = opt[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, filter)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []U
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) ([]U, error)); ok {
		return rf(ctx, filter, opt...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) []U); ok {
		r0 = rf(ctx, filter, opt...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]U)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, ...*repository.QueryOptions) error); ok {
		r1 = rf(ctx, filter, opt...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type Repository_Find_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - ctx context.Context
//   - filter interface{}
//   - opt ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) Find(ctx interface{}, filter interface{}, opt ...interface{}) *Repository_Find_Call[T, U] {
	return &Repository_Find_Call[T, U]{Call: _e.mock.On("Find",
		append([]interface{}{ctx, filter}, opt...)...)}
}

func (_c *Repository_Find_Call[T, U]) Run(run func(ctx context.Context, filter interface{}, opt ...*repository.QueryOptions)) *Repository_Find_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Find_Call[T, U]) Return(_a0 []U, _a1 error) *Repository_Find_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_Find_Call[T, U]) RunAndReturn(run func(context.Context, interface{}, ...*repository.QueryOptions) ([]U, error)) *Repository_Find_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function with given fields: ctx, id, options
func (_m *Repository[T, U]) FindByID(ctx context.Context, id interface{}, options ...*repository.QueryOptions) (U, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 U
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) (U, error)); ok {
		return rf(ctx, id, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) U); ok {
		r0 = rf(ctx, id, options...)
	} else {
		r0 = ret.Get(0).(U)
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, ...*repository.QueryOptions) error); ok {
		r1 = rf(ctx, id, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type Repository_FindByID_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id interface{}
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) FindByID(ctx interface{}, id interface{}, options ...interface{}) *Repository_FindByID_Call[T, U] {
	return &Repository_FindByID_Call[T, U]{Call: _e.mock.On("FindByID",
		append([]interface{}{ctx, id}, options...)...)}
}

func (_c *Repository_FindByID_Call[T, U]) Run(run func(ctx context.Context, id interface{}, options ...*repository.QueryOptions)) *Repository_FindByID_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Repository_FindByID_Call[T, U]) Return(_a0 U, _a1 error) *Repository_FindByID_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_FindByID_Call[T, U]) RunAndReturn(run func(context.Context, interface{}, ...*repository.QueryOptions) (U, error)) *Repository_FindByID_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// FindByIDs provides a mock function with given fields: ctx, ids, preserveOrder, options
func (_m *Repository[T, U]) FindByIDs(ctx context.Context, ids []interface{}, preserveOrder bool, options ...*repository.QueryOptions) ([]U, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, ids, preserveOrder)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []U
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []interface{}, bool, ...*repository.QueryOptions) ([]U, error)); ok {
		return rf(ctx, ids, preserveOrder, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []interface{}, bool, ...*repository.QueryOptions) []U); ok {
		r0 = rf(ctx, ids, preserveOrder, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]U)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []interface{}, bool, ...*repository.QueryOptions) error); ok {
		r1 = rf(ctx, ids, preserveOrder, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_FindByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByIDs'
type Repository_FindByIDs_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// FindByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []interface{}
//   - preserveOrder bool
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) FindByIDs(ctx interface{}, ids interface{}, preserveOrder interface{}, options ...interface{}) *Repository_FindByIDs_Call[T, U] {
	return &Repository_FindByIDs_Call[T, U]{Call: _e.mock.On("FindByIDs",
		append([]interface{}{ctx, ids, preserveOrder}, options...)...)}
}

func (_c *Repository_FindByIDs_Call[T, U]) Run(run func(ctx context.Context, ids []interface{}, preserveOrder bool, options ...*repository.QueryOptions)) *Repository_FindByIDs_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].([]interface{}), args[2].(bool), variadicArgs...)
	})
	return _c
}

func (_c *Repository_FindByIDs_Call[T, U]) Return(_a0 []U, _a1 error) *Repository_FindByIDs_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_FindByIDs_Call[T, U]) RunAndReturn(run func(context.Context, []interface{}, bool, ...*repository.QueryOptions) ([]U, error)) *Repository_FindByIDs_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// FindByStringIDs provides a mock function with given fields: ctx, ids, preserveOrder, options
func (_m *Repository[T, U]) FindByStringIDs(ctx context.Context, ids []string, preserveOrder bool, options ...*repository.QueryOptions) ([]U, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, ids, preserveOrder)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []U
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, bool, ...*repository.QueryOptions) ([]U, error)); ok {
		return rf(ctx, ids, preserveOrder, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, bool, ...*repository.QueryOptions) []U); ok {
		r0 = rf(ctx, ids, preserveOrder, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]U)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, bool, ...*repository.QueryOptions) error); ok {
		r1 = rf(ctx, ids, preserveOrder, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_FindByStringIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByStringIDs'
type Repository_FindByStringIDs_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// FindByStringIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []string
//   - preserveOrder bool
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) FindByStringIDs(ctx interface{}, ids interface{}, preserveOrder interface{}, options ...interface{}) *Repository_FindByStringIDs_Call[T, U] {
	return &Repository_FindByStringIDs_Call[T, U]{Call: _e.mock.On("FindByStringIDs",
		append([]interface{}{ctx, ids, preserveOrder}, options...)...)}
}

func (_c *Repository_FindByStringIDs_Call[T, U]) Run(run func(ctx context.Context, ids []string, preserveOrder bool, options ...*repository.QueryOptions)) *Repository_FindByStringIDs_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].([]string), args[2].(bool), variadicArgs...)
	})
	return _c
}

func (_c *Repository_FindByStringIDs_Call[T, U]) Return(_a0 []U, _a1 error) *Repository_FindByStringIDs_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_FindByStringIDs_Call[T, U]) RunAndReturn(run func(context.Context, []string, bool, ...*repository.QueryOptions) ([]U, error)) *Repository_FindByStringIDs_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// FindOne provides a mock function with given fields: ctx, filter, opts
func (_m *Repository[T, U]) FindOne(ctx context.Context, filter interface{}, opts ...*repository.QueryOptions) (U, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, filter)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 U
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) (U, error)); ok {
		return rf(ctx, filter, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*repository.QueryOptions) U); ok {
		r0 = rf(ctx, filter, opts...)
	} else {
		r0 = ret.Get(0).(U)
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, ...*repository.QueryOptions) error); ok {
		r1 = rf(ctx, filter, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_FindOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOne'
type Repository_FindOne_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// FindOne is a helper method to define mock.On call
//   - ctx context.Context
//   - filter interface{}
//   - opts ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) FindOne(ctx interface{}, filter interface{}, opts ...interface{}) *Repository_FindOne_Call[T, U] {
	return &Repository_FindOne_Call[T, U]{Call: _e.mock.On("FindOne",
		append([]interface{}{ctx, filter}, opts...)...)}
}

func (_c *Repository_FindOne_Call[T, U]) Run(run func(ctx context.Context, filter interface{}, opts ...*repository.QueryOptions)) *Repository_FindOne_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Repository_FindOne_Call[T, U]) Return(_a0 U, _a1 error) *Repository_FindOne_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_FindOne_Call[T, U]) RunAndReturn(run func(context.Context, interface{}, ...*repository.QueryOptions) (U, error)) *Repository_FindOne_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// GetAll provides a mock function with given fields: ctx, options
func (_m *Repository[T, U]) GetAll(ctx context.Context, options ...*repository.QueryOptions) ([]U, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []U
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*repository.QueryOptions) ([]U, error)); ok {
		return rf(ctx, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...*repository.QueryOptions) []U); ok {
		r0 = rf(ctx, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]U)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...*repository.QueryOptions) error); ok {
		r1 = rf(ctx, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type Repository_GetAll_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// GetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) GetAll(ctx interface{}, options ...interface{}) *Repository_GetAll_Call[T, U] {
	return &Repository_GetAll_Call[T, U]{Call: _e.mock.On("GetAll",
		append([]interface{}{ctx}, options...)...)}
}

func (_c *Repository_GetAll_Call[T, U]) Run(run func(ctx context.Context, options ...*repository.QueryOptions)) *Repository_GetAll_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *Repository_GetAll_Call[T, U]) Return(_a0 []U, _a1 error) *Repository_GetAll_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_GetAll_Call[T, U]) RunAndReturn(run func(context.Context, ...*repository.QueryOptions) ([]U, error)) *Repository_GetAll_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function with given fields: ctx, entity
func (_m *Repository[T, U]) Insert(ctx context.Context, entity U) error {
	ret := _m.Called(ctx, entity)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, U) error); ok {
		r0 = rf(ctx, entity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type Repository_Insert_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - ctx context.Context
//   - entity U
func (_e *Repository_Expecter[T, U]) Insert(ctx interface{}, entity interface{}) *Repository_Insert_Call[T, U] {
	return &Repository_Insert_Call[T, U]{Call: _e.mock.On("Insert", ctx, entity)}
}

func (_c *Repository_Insert_Call[T, U]) Run(run func(ctx context.Context, entity U)) *Repository_Insert_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(U))
	})
	return _c
}

func (_c *Repository_Insert_Call[T, U]) Return(_a0 error) *Repository_Insert_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Insert_Call[T, U]) RunAndReturn(run func(context.Context, U) error) *Repository_Insert_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// InsertMany provides a mock function with given fields: ctx, entities
func (_m *Repository[T, U]) InsertMany(ctx context.Context, entities []U) error {
	ret := _m.Called(ctx, entities)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []U) error); ok {
		r0 = rf(ctx, entities)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_InsertMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertMany'
type Repository_InsertMany_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// InsertMany is a helper method to define mock.On call
//   - ctx context.Context
//   - entities []U
func (_e *Repository_Expecter[T, U]) InsertMany(ctx interface{}, entities interface{}) *Repository_InsertMany_Call[T, U] {
	return &Repository_InsertMany_Call[T, U]{Call: _e.mock.On("InsertMany", ctx, entities)}
}

func (_c *Repository_InsertMany_Call[T, U]) Run(run func(ctx context.Context, entities []U)) *Repository_InsertMany_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]U))
	})
	return _c
}

func (_c *Repository_InsertMany_Call[T, U]) Return(_a0 error) *Repository_InsertMany_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_InsertMany_Call[T, U]) RunAndReturn(run func(context.Context, []U) error) *Repository_InsertMany_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function with given fields:
func (_m *Repository[T, U]) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Repository_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type Repository_Name_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *Repository_Expecter[T, U]) Name() *Repository_Name_Call[T, U] {
	return &Repository_Name_Call[T, U]{Call: _e.mock.On("Name")}
}

func (_c *Repository_Name_Call[T, U]) Run(run func()) *Repository_Name_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Repository_Name_Call[T, U]) Return(_a0 string) *Repository_Name_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Name_Call[T, U]) RunAndReturn(run func() string) *Repository_Name_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, entity, options
func (_m *Repository[T, U]) Update(ctx context.Context, entity U, options ...*repository.QueryOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, entity)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, U, ...*repository.QueryOptions) error); ok {
		r0 = rf(ctx, entity, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Repository_Update_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - entity U
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) Update(ctx interface{}, entity interface{}, options ...interface{}) *Repository_Update_Call[T, U] {
	return &Repository_Update_Call[T, U]{Call: _e.mock.On("Update",
		append([]interface{}{ctx, entity}, options...)...)}
}

func (_c *Repository_Update_Call[T, U]) Run(run func(ctx context.Context, entity U, options ...*repository.QueryOptions)) *Repository_Update_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(U), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Update_Call[T, U]) Return(_a0 error) *Repository_Update_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Update_Call[T, U]) RunAndReturn(run func(context.Context, U, ...*repository.QueryOptions) error) *Repository_Update_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// UpdateAndGetByID provides a mock function with given fields: ctx, updateEntity, returnNewDocument, queryOpt
func (_m *Repository[T, U]) UpdateAndGetByID(ctx context.Context, updateEntity U, returnNewDocument bool, queryOpt ...*repository.QueryOptions) (U, error) {
	_va := make([]interface{}, len(queryOpt))
	for _i := range queryOpt {
		_va[_i] = queryOpt[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, updateEntity, returnNewDocument)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 U
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, U, bool, ...*repository.QueryOptions) (U, error)); ok {
		return rf(ctx, updateEntity, returnNewDocument, queryOpt...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, U, bool, ...*repository.QueryOptions) U); ok {
		r0 = rf(ctx, updateEntity, returnNewDocument, queryOpt...)
	} else {
		r0 = ret.Get(0).(U)
	}

	if rf, ok := ret.Get(1).(func(context.Context, U, bool, ...*repository.QueryOptions) error); ok {
		r1 = rf(ctx, updateEntity, returnNewDocument, queryOpt...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_UpdateAndGetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAndGetByID'
type Repository_UpdateAndGetByID_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// UpdateAndGetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - updateEntity U
//   - returnNewDocument bool
//   - queryOpt ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) UpdateAndGetByID(ctx interface{}, updateEntity interface{}, returnNewDocument interface{}, queryOpt ...interface{}) *Repository_UpdateAndGetByID_Call[T, U] {
	return &Repository_UpdateAndGetByID_Call[T, U]{Call: _e.mock.On("UpdateAndGetByID",
		append([]interface{}{ctx, updateEntity, returnNewDocument}, queryOpt...)...)}
}

func (_c *Repository_UpdateAndGetByID_Call[T, U]) Run(run func(ctx context.Context, updateEntity U, returnNewDocument bool, queryOpt ...*repository.QueryOptions)) *Repository_UpdateAndGetByID_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(U), args[2].(bool), variadicArgs...)
	})
	return _c
}

func (_c *Repository_UpdateAndGetByID_Call[T, U]) Return(_a0 U, _a1 error) *Repository_UpdateAndGetByID_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_UpdateAndGetByID_Call[T, U]) RunAndReturn(run func(context.Context, U, bool, ...*repository.QueryOptions) (U, error)) *Repository_UpdateAndGetByID_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// UpdateMany provides a mock function with given fields: ctx, entities
func (_m *Repository[T, U]) UpdateMany(ctx context.Context, entities []U) error {
	ret := _m.Called(ctx, entities)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []U) error); ok {
		r0 = rf(ctx, entities)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_UpdateMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMany'
type Repository_UpdateMany_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// UpdateMany is a helper method to define mock.On call
//   - ctx context.Context
//   - entities []U
func (_e *Repository_Expecter[T, U]) UpdateMany(ctx interface{}, entities interface{}) *Repository_UpdateMany_Call[T, U] {
	return &Repository_UpdateMany_Call[T, U]{Call: _e.mock.On("UpdateMany", ctx, entities)}
}

func (_c *Repository_UpdateMany_Call[T, U]) Run(run func(ctx context.Context, entities []U)) *Repository_UpdateMany_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]U))
	})
	return _c
}

func (_c *Repository_UpdateMany_Call[T, U]) Return(_a0 error) *Repository_UpdateMany_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_UpdateMany_Call[T, U]) RunAndReturn(run func(context.Context, []U) error) *Repository_UpdateMany_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// UpdateOne provides a mock function with given fields: ctx, filter, update, options
func (_m *Repository[T, U]) UpdateOne(ctx context.Context, filter interface{}, update interface{}, options ...*repository.QueryOptions) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, filter, update)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}, ...*repository.QueryOptions) error); ok {
		r0 = rf(ctx, filter, update, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_UpdateOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOne'
type Repository_UpdateOne_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// UpdateOne is a helper method to define mock.On call
//   - ctx context.Context
//   - filter interface{}
//   - update interface{}
//   - options ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) UpdateOne(ctx interface{}, filter interface{}, update interface{}, options ...interface{}) *Repository_UpdateOne_Call[T, U] {
	return &Repository_UpdateOne_Call[T, U]{Call: _e.mock.On("UpdateOne",
		append([]interface{}{ctx, filter, update}, options...)...)}
}

func (_c *Repository_UpdateOne_Call[T, U]) Run(run func(ctx context.Context, filter interface{}, update interface{}, options ...*repository.QueryOptions)) *Repository_UpdateOne_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(interface{}), args[2].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Repository_UpdateOne_Call[T, U]) Return(_a0 error) *Repository_UpdateOne_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_UpdateOne_Call[T, U]) RunAndReturn(run func(context.Context, interface{}, interface{}, ...*repository.QueryOptions) error) *Repository_UpdateOne_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function with given fields: ctx, entity, opt
func (_m *Repository[T, U]) Upsert(ctx context.Context, entity U, opt ...*repository.QueryOptions) error {
	_va := make([]interface{}, len(opt))
	for _i := range opt {
		_va[_i] = opt[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, entity)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, U, ...*repository.QueryOptions) error); ok {
		r0 = rf(ctx, entity, opt...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type Repository_Upsert_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - ctx context.Context
//   - entity U
//   - opt ...*repository.QueryOptions
func (_e *Repository_Expecter[T, U]) Upsert(ctx interface{}, entity interface{}, opt ...interface{}) *Repository_Upsert_Call[T, U] {
	return &Repository_Upsert_Call[T, U]{Call: _e.mock.On("Upsert",
		append([]interface{}{ctx, entity}, opt...)...)}
}

func (_c *Repository_Upsert_Call[T, U]) Run(run func(ctx context.Context, entity U, opt ...*repository.QueryOptions)) *Repository_Upsert_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*repository.QueryOptions, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*repository.QueryOptions)
			}
		}
		run(args[0].(context.Context), args[1].(U), variadicArgs...)
	})
	return _c
}

func (_c *Repository_Upsert_Call[T, U]) Return(_a0 error) *Repository_Upsert_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_Upsert_Call[T, U]) RunAndReturn(run func(context.Context, U, ...*repository.QueryOptions) error) *Repository_Upsert_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// UpsertOne provides a mock function with given fields: ctx, filter, update
func (_m *Repository[T, U]) UpsertOne(ctx context.Context, filter interface{}, update U) error {
	ret := _m.Called(ctx, filter, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, U) error); ok {
		r0 = rf(ctx, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Repository_UpsertOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertOne'
type Repository_UpsertOne_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// UpsertOne is a helper method to define mock.On call
//   - ctx context.Context
//   - filter interface{}
//   - update U
func (_e *Repository_Expecter[T, U]) UpsertOne(ctx interface{}, filter interface{}, update interface{}) *Repository_UpsertOne_Call[T, U] {
	return &Repository_UpsertOne_Call[T, U]{Call: _e.mock.On("UpsertOne", ctx, filter, update)}
}

func (_c *Repository_UpsertOne_Call[T, U]) Run(run func(ctx context.Context, filter interface{}, update U)) *Repository_UpsertOne_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(interface{}), args[2].(U))
	})
	return _c
}

func (_c *Repository_UpsertOne_Call[T, U]) Return(_a0 error) *Repository_UpsertOne_Call[T, U] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Repository_UpsertOne_Call[T, U]) RunAndReturn(run func(context.Context, interface{}, U) error) *Repository_UpsertOne_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// WithTransaction provides a mock function with given fields: ctx, f
func (_m *Repository[T, U]) WithTransaction(ctx context.Context, f func(mongo.SessionContext) (interface{}, error)) (interface{}, error) {
	ret := _m.Called(ctx, f)

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(mongo.SessionContext) (interface{}, error)) (interface{}, error)); ok {
		return rf(ctx, f)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(mongo.SessionContext) (interface{}, error)) interface{}); ok {
		r0 = rf(ctx, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(mongo.SessionContext) (interface{}, error)) error); ok {
		r1 = rf(ctx, f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Repository_WithTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTransaction'
type Repository_WithTransaction_Call[T interface{}, U repository.IEntityIDPtr[T]] struct {
	*mock.Call
}

// WithTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - f func(mongo.SessionContext)(interface{} , error)
func (_e *Repository_Expecter[T, U]) WithTransaction(ctx interface{}, f interface{}) *Repository_WithTransaction_Call[T, U] {
	return &Repository_WithTransaction_Call[T, U]{Call: _e.mock.On("WithTransaction", ctx, f)}
}

func (_c *Repository_WithTransaction_Call[T, U]) Run(run func(ctx context.Context, f func(mongo.SessionContext) (interface{}, error))) *Repository_WithTransaction_Call[T, U] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(mongo.SessionContext) (interface{}, error)))
	})
	return _c
}

func (_c *Repository_WithTransaction_Call[T, U]) Return(_a0 interface{}, _a1 error) *Repository_WithTransaction_Call[T, U] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Repository_WithTransaction_Call[T, U]) RunAndReturn(run func(context.Context, func(mongo.SessionContext) (interface{}, error)) (interface{}, error)) *Repository_WithTransaction_Call[T, U] {
	_c.Call.Return(run)
	return _c
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository[T interface{}, U repository.IEntityIDPtr[T]](t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository[T, U] {
	mock := &Repository[T, U]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
